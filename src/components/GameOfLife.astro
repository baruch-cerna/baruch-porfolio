<canvas
  id="game-of-life"
  class="fixed top-0 left-0 w-full h-screen -z-10 opacity-40"></canvas>

<script>
  // TypeScript Logic for Game of Life
  interface Cell {
    state: number;
    opacity: number;
  }

  interface Rules {
    born: number[];
    survive: number[];
  }

  const canvas = document.getElementById("game-of-life") as HTMLCanvasElement;

  if (canvas) {
    const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
    const genCounter = document.getElementById("gen-counter");
    const ruleDisplay = document.getElementById("rule-display");

    // Configuration
    const cellSize = 8;
    const speed = 30;
    const density = 0.1;
    const trailFade = 0.5;

    const rules: Rules = {
      born: [3],
      survive: [1, 2, 3, 4, 5],
    };

    let width: number, height: number;
    let cols: number, rows: number;
    let grid: Cell[][] = [];
    let animationId: number;
    let generation = 0;

    // Update UI
    if (ruleDisplay) {
      ruleDisplay.innerText = `B${rules.born.join("")}/S${rules.survive.join("")}`;
    }

    function create2DArray(c: number, r: number): Cell[][] {
      let arr = new Array(c);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = new Array(r);
      }
      return arr;
    }

    function initGrid() {
      grid = create2DArray(cols, rows);
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j] = {
            state: Math.random() < density ? 1 : 0,
            opacity: 0,
          };
        }
      }
    }

    function countNeighbors(
      currentGrid: Cell[][],
      x: number,
      y: number,
    ): number {
      let sum = 0;
      for (let i = -1; i < 2; i++) {
        for (let j = -1; j < 2; j++) {
          let col = (x + i + cols) % cols;
          let row = (y + j + rows) % rows;
          sum += currentGrid[col][row].state;
        }
      }
      sum -= currentGrid[x][y].state;
      return sum;
    }

    function update() {
      let next = create2DArray(cols, rows);

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          let state = grid[i][j].state;
          let opacity = grid[i][j].opacity;

          let neighbors = countNeighbors(grid, i, j);

          if (state === 0 && rules.born.includes(neighbors)) {
            next[i][j] = { state: 1, opacity: 1 };
          } else if (state === 1 && !rules.survive.includes(neighbors)) {
            next[i][j] = { state: 0, opacity: opacity };
          } else {
            next[i][j] = { state: state, opacity: opacity };
          }
        }
      }

      grid = next;
      generation++;
      if (genCounter) genCounter.innerText = generation.toString();
    }

    function draw() {
      ctx.fillStyle = "rgba(5, 5, 5, 0.3)";
      ctx.fillRect(0, 0, width, height);

      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          let cell = grid[i][j];

          if (cell.state === 1) {
            cell.opacity = 1;
            ctx.fillStyle = "rgba(80, 80, 80, 1)";
            ctx.beginPath();
            ctx.rect(i * cellSize, j * cellSize, cellSize, cellSize);

            ctx.fill();
          } else if (cell.opacity > 0) {
            cell.opacity -= trailFade;
            if (cell.opacity < 0) cell.opacity = 0;

            ctx.fillStyle = `rgba(60, 60, 60, ${cell.opacity})`;
            ctx.beginPath();
            ctx.rect(i * cellSize, j * cellSize, cellSize, cellSize);
            ctx.fill();
          }
        }
      }
    }

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      cols = Math.ceil(width / cellSize);
      rows = Math.ceil(height / cellSize);
      initGrid();
    }

    function loop() {
      update();
      draw();
      animationId = window.setTimeout(() => {
        requestAnimationFrame(loop);
      }, speed);
    }

    // Mouse Interaction
    document.addEventListener("mousemove", (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      const gridX = Math.floor(mouseX / cellSize);
      const gridY = Math.floor(mouseY / cellSize);

      if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (Math.random() > 0.5) {
              let cx = (gridX + i + cols) % cols;
              let cy = (gridY + j + rows) % rows;
              grid[cx][cy].state = 1;
            }
          }
        }
      }
    });

    window.addEventListener("resize", () => {
      clearTimeout(animationId);
      resize();
      loop();
    });

    // Initialize
    resize();
    loop();
  }
</script>
